<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â°îÈò≤ÔºöÁªàÊûÅÈò≤Á©∫Áâà (ÈªëÁõíÂ≠òÊ°£Áâà)</title>
    <style>
        body {
            margin: 0; background: #000; color: #ddd;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100dvh;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }

        #shaker { width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; }

        /* --- ÁïåÈù¢ÈÄöÁî®Ê†∑Âºè --- */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 40px; color: #00e676; text-shadow: 0 0 20px #00e676; margin-bottom: 40px; letter-spacing: 2px; text-transform: uppercase; text-align: center;}
        .menu-btn {
            background: #1b5e20; border: 1px solid #69f0ae; color: #fff;
            padding: 15px 40px; font-size: 18px; margin: 10px; cursor: pointer;
            border-radius: 4px; transition: 0.2s; width: 220px; text-align: center;
            font-family: monospace; font-weight: bold;
        }
        .menu-btn:hover { background: #00e676; color: #000; box-shadow: 0 0 15px #00e676; }
        .menu-btn.secondary { background: #37474f; border-color: #90a4ae; }
        .menu-btn.secondary:hover { background: #90a4ae; color: #000; box-shadow: 0 0 15px #fff; }

        /* È°∂ÈÉ®Ê†è */
        #top-bar {
            height: 44px; background: #111; display: flex; justify-content: space-between;
            align-items: center; padding: 0 15px; border-bottom: 1px solid #333;
            font-size: 13px; font-weight: bold; flex-shrink: 0; z-index: 20;
            box-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        .stat-group { display: flex; gap: 12px; }
        .stat-val { color: #f0c040; margin-left: 4px; font-family: monospace; font-size: 16px; text-shadow: 0 0 5px #f0c040; transition: color 0.2s; }
        .stat-val.gain { color: #fff !important; text-shadow: 0 0 10px #fff; transform: scale(1.2); }

        .top-controls { display: flex; gap: 10px; align-items: center; }
        #auto-switch {
            background: #222; padding: 4px 10px; border-radius: 20px;
            font-size: 12px; color: #888; border: 1px solid #444;
            display: flex; align-items: center; gap: 5px; transition: 0.3s; cursor: pointer;
        }
        #auto-switch.on { background: #00c853; color: white; border-color: #69f0ae; box-shadow: 0 0 8px #69f0ae; }
        
        #pause-btn {
            background: #333; border: 1px solid #555; color: #fff; width: 30px; height: 30px;
            border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer;
        }

        /* Ê∏∏ÊàèÂå∫ */
        #game-wrapper {
            flex: 1; position: relative; background: #080808;
            display: flex; justify-content: center; align-items: flex-start;
            overflow: hidden;
        }
        canvas { display: block; image-rendering: pixelated; }

        /* ÂÄíËÆ°Êó∂ÊµÆÂ±Ç */
        #countdown-overlay {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 15px;
            font-size: 12px; color: #fff; pointer-events: none; display: none; border: 1px solid #555;
        }

        /* Â∫ïÈÉ®ÊéßÂà∂Âå∫ */
        #bottom-panel {
            height: 150px; background: #0e0e0e; border-top: 1px solid #333;
            display: flex; flex-direction: column; flex-shrink: 0; z-index: 10;
        }
        #wave-control-btn {
            height: 32px; background: #b71c1c; color: white; border: none;
            font-size: 14px; font-weight: bold; width: 100%; letter-spacing: 2px;
            transition: 0.2s; text-transform: uppercase; cursor: pointer;
        }
        #wave-control-btn:active { background: #ff1744; filter: brightness(1.3); }
        #wave-control-btn:disabled { background: #222; color: #555; cursor: default; }

        /* ÂïÜÂ∫ó */
        #shop {
            flex: 1; display: flex; overflow-x: auto; padding: 8px;
            align-items: center; gap: 6px; scrollbar-width: none;
        }
        #shop::-webkit-scrollbar { display: none; }

        .shop-card {
            min-width: 74px; height: 95px; background: #181818;
            border: 1px solid #333; border-radius: 6px;
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; position: relative; transition: 0.1s; cursor: pointer;
        }
        .shop-card.active { border-color: #00c853; background: #0f2015; transform: translateY(-3px); box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .shop-card.disabled { opacity: 0.3; filter: grayscale(100%); cursor: not-allowed; }
        
        .icon-box {
            width: 32px; height: 32px; border-radius: 4px;
            margin-bottom: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            font-size: 20px; display: flex; align-items: center; justify-content: center;
        }
        .card-name { font-size: 10px; font-weight: bold; margin-bottom: 2px; color: #ccc; text-align: center;}
        .card-cost { font-size: 11px; color: #ffd700; font-family: monospace; font-weight: bold; }
        .card-desc { font-size: 9px; color: #aaa; transform: scale(0.85); white-space: nowrap; margin-top: -1px;}
        
        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 8px 18px; border-radius: 4px; border: 1px solid #00c853;
            font-size: 13px; color: #fff; pointer-events: none; opacity: 0; transition: opacity 0.2s;
            text-align: center; white-space: nowrap; z-index: 50;
        }

        #file-input { display: none; }
    </style>
</head>
<body>

<div id="start-screen" class="overlay-screen">
    <h1>PLANET DEFENSE<br><span style="font-size:20px; color:#aaa">BLACK BOX EDITION</span></h1>
    <button class="menu-btn" onclick="startNewGame()">ÂºÄÂßãÊñ∞Ê∏∏Êàè</button>
    <button class="menu-btn secondary" onclick="document.getElementById('file-input').click()">ÂØºÂÖ•ÂØπÂ±Ä</button>
    <div style="margin-top:20px; font-size:12px; color:#555">Ver 1.2.0 - Anti-AI Obfuscation</div>
</div>

<div id="pause-screen" class="overlay-screen hidden">
    <h2 style="color:#fff; margin-bottom:30px">GAME PAUSED</h2>
    <button class="menu-btn" onclick="togglePause()">ÁªßÁª≠Ê∏∏Êàè</button>
    <button class="menu-btn secondary" onclick="exportSave()">ÂØºÂá∫ÂΩìÂâçÂØπÂ±Ä</button>
    <button class="menu-btn secondary" style="border-color:#ff5252; color:#ff5252" onclick="location.reload()">ËøîÂõû‰∏ªËèúÂçï</button>
</div>

<input type="file" id="file-input" accept=".pds" onchange="handleFileImport(this)">

<div id="shaker">
    <div id="top-bar">
        <div class="stat-group">
            <div>üí∞<span id="gold-display" class="stat-val">6000</span></div>
            <div>‚ù§Ô∏è<span id="life-display" class="stat-val" style="color:#ff5252">30</span></div>
            <div>üåä<span id="wave-display" class="stat-val" style="color:#40c4ff">0</span></div>
        </div>
        <div class="top-controls">
            <div id="auto-switch" onclick="toggleAuto()">
                <div style="width:6px;height:6px;border-radius:50%;background:currentColor"></div>
                Ëá™Âä®
            </div>
            <div id="pause-btn" onclick="togglePause()">‚è∏</div>
        </div>
    </div>

    <div id="game-wrapper">
        <div id="countdown-overlay">‰∏ã‰∏ÄÊ≥¢: <span id="cd-num">3</span>s</div>
        <canvas id="gameCanvas"></canvas>
        <div id="toast">ÊèêÁ§∫‰ø°ÊÅØ</div>
    </div>

    <div id="bottom-panel">
        <button id="wave-control-btn" onclick="manualNextWave()">‚öîÔ∏è ÊàòÊñóÂºÄÂßã</button>
        <div id="shop"></div>
    </div>
</div>

<script>
const MAP_COLS = 13; 
const MAP_ROWS = 21; 
let TILE_SIZE = 0;

// Ê∏∏ÊàèÁä∂ÊÄÅÊûö‰∏æ
const STATE = { MENU: 0, PLAYING: 1, PAUSED: 2, GAMEOVER: 3 };
let gameState = STATE.MENU;

// Âª∫Á´ãÁ¥¢ÂºïÊò†Â∞ÑÔºåÁî®‰∫éÂ≠òÊ°£Êó∂ÂéªËØ≠‰πâÂåñ
const TOWER_KEYS = ['VULCAN', 'FLAK', 'NET', 'TESLA', 'MAGMA', 'BUFF', 'PRISM', 'MISSILE', 'NUKE', 'GOLD', 'DRONE'];
const ENEMY_KEYS = ['NORMAL', 'FAST', 'SHIELD', 'TANK', 'BOSS', 'GHOST', 'FLY', 'FLY_H', 'MEDIC', 'SPIDER', 'MINI', 'REAPER', 'DASHER'];

const TOWER_TYPES = {
    VULCAN: { id: 'vulcan', name: 'ÁÅ´Á•ûÁÇÆ', cost: 200, color: '#ff8a65', icon:'üî´', range: 5.0, damage: 30, cooldown: 5, desc: 'Âä†ÁâπÊûó/Ë∂äÊâìË∂äÂø´' },
    FLAK:   { id: 'flak',   name: 'Êö¥È£éÈò≤Á©∫', cost: 450, color: '#90a4ae', icon:'üå™Ô∏è', range: 7.0, damage: 150, cooldown: 15, desc: 'ÂØπÁ©∫AOE/ÈáçÁî≤3ÂÄç' }, 
    NET:    { id: 'net',    name: 'Â§©ÁΩëÊçïÊâã', cost: 500, color: '#aa00ff', icon:'üï∏Ô∏è', range: 6.5, damage: 20, cooldown: 8, desc: 'ÂáèÈÄü/ÁôæÂàÜÊØîÂàáÂâ≤' }, 
    TESLA:  { id: 'tesla',  name: 'ÁîµÁ£ÅÂ°î', cost: 650, color: '#2979ff', icon:'‚ö°', range: 5.5, damage: 110, cooldown: 35, desc: 'ËøûÈîÅ/ÁîµËç∑ÁàÜÁÇ∏' }, 
    MAGMA:  { id: 'magma',  name: 'ÁÜîÂ≤©Â°î', cost: 850, color: '#ff5722', icon:'üî•', range: 5.5, damage: 40, cooldown: 45, desc: 'Âà∂ÈÄ†ÁáÉÁÉßÂú∞ÂΩ¢' },
    BUFF:   { id: 'buff',   name: 'Â¢ûÂπÖÂô®', cost: 2000, color: '#00e676', icon:'üì°', range: 3.5, damage: 0, cooldown: 0, desc: 'ÂáÄÂåñ/5Á∫ß‰º§+100%' },
    PRISM:  { id: 'prism',  name: 'ÂÖâÊ£±Â°î', cost: 750, color: '#f50057', icon:'üî¶', range: 7.0, damage: 55, cooldown: 0, desc: 'ÊøÄÂÖâ/ÊäòÂ∞ÑÊï£Â∞Ñ' },
    MISSILE:{ id: 'missile',name: 'ËøΩÁåéËÄÖ', cost: 1200, color: '#37474f', icon:'üöÄ', range: 30.0, damage: 1000, cooldown: 70, desc: 'ÂÖ®Âõæ/Â§öÈáçÈΩêÂ∞Ñ' }, 
    NUKE:   { id: 'nuke',   name: 'Ê†∏Âºπ‰∫ï', cost: 1800, color: '#d50000', icon:'‚ò¢Ô∏è', range: 6.0, damage: 10000, cooldown: 150, desc: 'ÂÖ®Â±èÈúáÊÖë' },
    GOLD:   { id: 'gold',   name: 'ÈªëÂøÉÁüø', cost: 400, color: '#fdd835', icon:'üí∞', range: 3.0, damage: 0, cooldown: 10, desc: 'Êö¥Âà©/ËµèÈáëÂÖâÁéØ' },
    DRONE:  { id: 'drone',  name: 'Êà™ÂáªÊú∫', cost: 150, color: '#00bcd4', icon:'‚úàÔ∏è', range: 8.0, damage: 40, cooldown: 12, desc: 'ÂØπÂú∞Á©∫/4Êû∂ËøáËΩΩ' }
};

const ENEMY_TYPES = {
    NORMAL:   { hp: 140, speed: 1.0, shield: 0, color: '#81c784', reward: 12, type: 'ground' },
    FAST:     { hp: 90,  speed: 2.2, shield: 0, color: '#ff5252', reward: 15, type: 'ground' }, 
    SHIELD:   { hp: 400, speed: 0.7, shield: 500, color: '#90a4ae', reward: 30, type: 'ground', border: '#cfd8dc' },
    TANK:     { hp: 1600, speed: 0.45, shield: 200, color: '#5d4037', reward: 80, type: 'ground', size: 1.4 }, 
    BOSS:     { hp: 8000, speed: 0.35, shield: 4000, color: '#6200ea', reward: 1000, type: 'ground', size: 1.9, border: '#ff0' },
    GHOST:    { hp: 100, speed: 1.6, shield: 0, color: 'rgba(255,255,255,0.4)', reward: 20, type: 'ground' }, 
    FLY:      { hp: 200, speed: 1.0, shield: 0, color: '#ffab00', reward: 35, type: 'air' },
    FLY_H:    { hp: 1000, speed: 0.8, shield: 100, color: '#e65100', reward: 100, type: 'air', size: 1.5, border: '#fff' },
    MEDIC:    { hp: 1100, speed: 0.8, shield: 300, color: '#f06292', reward: 40, type: 'ground', size: 1.1, desc: 'Ê≤ªÁñóÂÖâÁéØ' },
    SPIDER:   { hp: 550, speed: 0.9, shield: 0, color: '#7b1fa2', reward: 35, type: 'ground', size: 1.2, desc: '‰∫°ËØ≠ÂàÜË£Ç' },
    MINI:     { hp: 40,  speed: 2.4, shield: 0, color: '#ab47bc', reward: 5, type: 'ground', size: 0.6 },
    REAPER:   { hp: 4000, speed: 0.55, shield: 2000, color: '#212121', reward: 300, type: 'ground', size: 1.5, border: '#b71c1c' },
    DASHER:   { hp: 800, speed: 0.6, shield: 100, color: '#00e5ff', reward: 50, type: 'ground', size: 1.0, desc: 'ÊûÅÈÄüÂÜ≤Âà∫' }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let map = [], path = [];
let towers = [], enemies = [], projectiles = [], particles = [], zones = [];
let gold = 6000;
let lives = 30;
let wave = 0;
let selectedTower = null;
let shakeTimer = 0;

let waveActive = false;
let spawnQueue = [];
let spawnTimer = 0;
let autoWave = false;
let autoTimer = 0;
const AUTO_DELAY_SEC = 2;

function init() {
    resize();
    window.addEventListener('resize', resize);
    generateMaze();
    initUI();
    // ÂàùÂßãÁä∂ÊÄÅ‰∏∫ËèúÂçïÔºå‰∏çÁõ¥Êé•ÂºÄÂßã
    gameState = STATE.MENU;
    requestAnimationFrame(gameLoop);
}

function startNewGame() {
    resetGame();
    document.getElementById('start-screen').classList.add('hidden');
    gameState = STATE.PLAYING;
}

function resetGame() {
    gold = 6000;
    lives = 30;
    wave = 0;
    towers = [];
    enemies = [];
    projectiles = [];
    particles = [];
    zones = [];
    waveActive = false;
    spawnQueue = [];
    autoWave = false;
    document.getElementById('auto-switch').classList.remove('on');
    updateUI();
}

function resize() {
    const w = document.getElementById('game-wrapper').clientWidth;
    TILE_SIZE = Math.floor(w / MAP_COLS);
    canvas.width = TILE_SIZE * MAP_COLS;
    canvas.height = TILE_SIZE * MAP_ROWS;
}

function initUI() {
    const shopDiv = document.getElementById('shop');
    shopDiv.innerHTML = '';
    for (let key in TOWER_TYPES) {
        const t = TOWER_TYPES[key];
        const btn = document.createElement('div');
        btn.className = 'shop-card';
        btn.id = 'btn-' + key;
        btn.onclick = () => selectTower(key);
        btn.innerHTML = `
            <div class="icon-box" style="background:${t.color}22; color:${t.color}">${t.icon}</div>
            <div class="card-name">${t.name}</div>
            <div class="card-desc">${t.desc}</div>
            <div class="card-cost">${t.cost}</div>
        `;
        shopDiv.appendChild(btn);
    }
}

function generateMaze() {
    map = Array(MAP_ROWS).fill(0).map(() => Array(MAP_COLS).fill(0));
    path = [];
    let c = 1, r = 0;
    map[r][c] = 1; path.push({c,r});
    for(r = 1; r < MAP_ROWS - 1; r++) {
        if (r % 2 !== 0) { 
             const dir = (Math.floor(r/2)%2 === 0) ? 1 : -1; 
             const start = (dir===1) ? 1 : MAP_COLS-2;
             const end = (dir===1) ? MAP_COLS-1 : 0;
             for(let i = start; i !== end; i += dir) {
                 map[r][i] = 1; path.push({c:i, r:r}); c = i;
             }
        } else { map[r][c] = 1; path.push({c,r}); }
    }
    map[MAP_ROWS-1][c] = 1; path.push({c,r:MAP_ROWS-1});
}

// ================= Ê†∏ÂøÉÁ±ªÂÆö‰πâ =================

class Enemy {
    constructor(typeKey, startX, startY, pathIdx) {
        if (!ENEMY_TYPES[typeKey]) typeKey = 'NORMAL';
        const t = ENEMY_TYPES[typeKey];
        this.typeKey = typeKey;
        
        let hpMult = 1 + (wave * 0.4);
        if (typeKey === 'MEDIC') hpMult = 1 + (wave * 0.65); 
        if (typeKey === 'REAPER') hpMult = 1 + (wave * 0.7);
        if (wave > 30) hpMult *= Math.pow(1.08, wave - 30); 
        if (typeKey === 'MINI') hpMult = 1 + (wave * 0.2); 

        this.hp = Math.floor(t.hp * hpMult);
        this.maxHp = this.hp;
        this.shield = Math.floor(t.shield * hpMult * 0.8);
        this.maxShield = this.shield;
        this.speedBase = t.speed * (1 + wave * 0.005); 
        this.color = t.color;
        this.reward = Math.floor(t.reward + wave * 0.6); 
        this.fly = (t.type === 'air');
        this.sizeScale = t.size || 1.0;
        this.border = t.border;
        this.active = true;
        
        if (startX !== undefined && startY !== undefined) {
            this.x = startX; this.y = startY; this.pathIdx = pathIdx;
        } else {
            this.x = path[0].c * TILE_SIZE + TILE_SIZE/2;
            this.y = path[0].r * TILE_SIZE + TILE_SIZE/2;
            this.pathIdx = 0;
        }

        this.webbed = 0; 
        this.healTimer = 0;
        this.skillTimer = 0; 
        this.dashTimer = 0;
        this.isDashing = false;

        if (this.fly) {
            this.endX = path[path.length-1].c * TILE_SIZE + TILE_SIZE/2;
            this.endY = path[path.length-1].r * TILE_SIZE + TILE_SIZE/2;
        }
    }

    update() {
        if (this.webbed > 0) this.webbed--;
        let spdMod = 1.0;
        if (this.webbed > 0) spdMod = 0.25; 

        if (this.typeKey === 'DASHER') {
            this.dashTimer++;
            if (this.isDashing) {
                spdMod *= 8.0; 
                if (this.dashTimer % 3 === 0) {
                     visualEffects.push({type:'dash_trail', x:this.x, y:this.y, life:10, color:this.color});
                }
                if (this.dashTimer > 30) { 
                    this.isDashing = false;
                    this.dashTimer = 0;
                }
            } else {
                if (this.dashTimer > 240) { 
                    this.isDashing = true;
                    this.dashTimer = 0;
                    createFloatingText(this.x, this.y - 10, "DASH!", "#00e5ff");
                }
            }
        }

        const currentSpeed = this.speedBase * spdMod * (TILE_SIZE / 40);
        
        if (this.typeKey === 'MEDIC') {
            this.healTimer++;
            if (this.healTimer > 30) {
                this.healTimer = 0;
                let healed = false;
                const range = 2.5 * TILE_SIZE;
                enemies.forEach(e => {
                    if (e !== this && e.active && e.hp < e.maxHp && !e.fly) {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < range) {
                            const amount = Math.floor(this.maxHp * 0.03) + 15;
                            e.hp = Math.min(e.maxHp, e.hp + amount);
                            createFloatingText(e.x, e.y - 10, "+" + amount, "#00e676");
                            visualEffects.push({ type: 'heal_beam', x: this.x, y: this.y, tx: e.x, ty: e.y, life: 10, maxLife: 10 });
                            healed = true;
                        }
                    }
                });
                if (healed) createExplosion(this.x, this.y, range, "rgba(0, 230, 118, 0.3)");
            }
        }

        if (this.typeKey === 'REAPER') {
            this.skillTimer++;
            if (this.skillTimer > 240) {
                this.skillTimer = 0;
                const range = 3.5 * TILE_SIZE;
                createExplosion(this.x, this.y, range, "rgba(120, 0, 255, 0.5)"); 
                createFloatingText(this.x, this.y-20, "SILENCE!", "#b388ff");
                towers.forEach(t => {
                    if (Math.hypot(t.x - this.x, t.y - this.y) < range) {
                        if (!t.buffStats.purified) {
                            t.frozen = 180; 
                            createFloatingText(t.x, t.y, "üö´", "#fff");
                        } else {
                            createFloatingText(t.x, t.y, "RESIST", "#00e676");
                        }
                    }
                });
            }
        }

        if (this.fly) {
            const dx = this.endX - this.x;
            const dy = this.endY - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < currentSpeed) this.reach();
            else { this.x += (dx/dist)*currentSpeed; this.y += (dy/dist)*currentSpeed; }
        } else {
            const target = path[this.pathIdx+1];
            if (!target) { this.reach(); return; }
            const tx = target.c * TILE_SIZE + TILE_SIZE/2;
            const ty = target.r * TILE_SIZE + TILE_SIZE/2;
            const dx = tx - this.x, dy = ty - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < currentSpeed) { this.x = tx; this.y = ty; this.pathIdx++; }
            else { this.x += (dx/dist)*currentSpeed; this.y += (dy/dist)*currentSpeed; }
        }
    }

    takeDamage(dmg, type, sourceTower) {
        if (this.fly) {
            if (!['air','nuke','net','flak','missile','prism','drone','tesla','vulcan'].includes(type)) return;
            if (type === 'flak' && this.typeKey === 'FLY_H') {
                dmg *= 3.0;
                createFloatingText(this.x, this.y-10, "CRIT!", "#f00");
            }
        }

        if (type === 'missile') {
            const missingHpPct = 1 - (this.hp / this.maxHp);
            dmg *= (1 + missingHpPct * 0.5); 
        }

        if (type === 'net' && sourceTower) {
            const pctDmg = Math.floor(this.maxHp * (0.005 * sourceTower.level));
            dmg += pctDmg;
        }

        if (this.shield > 0) {
            this.shield -= dmg;
            if (this.shield < 0) { this.hp += this.shield; this.shield = 0; }
        } else { this.hp -= dmg; }

        if (this.hp <= 0) {
            this.active = false;
            
            if (this.typeKey === 'SPIDER') {
                for (let i = 0; i < 3; i++) {
                    const offset = (Math.random() - 0.5) * 20;
                    enemies.push(new Enemy('MINI', this.x + offset, this.y + offset, this.pathIdx));
                }
                createFloatingText(this.x, this.y, "ÂàÜË£Ç!", "#ab47bc");
            }

            let finalReward = this.reward;
            if (sourceTower && sourceTower.bountyBuff > 0) {
                const bonus = Math.min(this.reward * 3, Math.floor(this.maxHp * 0.1));
                finalReward += bonus;
                createFloatingText(this.x, this.y - 10, `+${bonus} (ËµèÈáë)`, '#ffea00');
            }

            gold += finalReward;
            if (Math.random() > 0.7 && !sourceTower && this.typeKey !== 'MINI') createFloatingText(this.x, this.y, `+${this.reward}`, '#ffd700');
            updateUI();
        }
    }

    reach() {
        this.active = false;
        lives--;
        createFloatingText(this.x, this.y, "üíî", "red");
        updateUI();
        if(lives <= 0) { alert(`GAME OVER! WAVE: ${wave}`); location.reload(); }
    }

    draw() {
        const s = TILE_SIZE * 0.3 * this.sizeScale;
        
        if (this.typeKey === 'MEDIC') {
            const range = 2.5 * TILE_SIZE; 
            const pulse = Math.sin(Date.now() / 200) * 0.08 + 0.15;
            ctx.fillStyle = `rgba(0, 230, 118, ${pulse})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, range, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = `rgba(0, 230, 118, ${pulse + 0.2})`; ctx.lineWidth = 1; ctx.stroke();
        }

        if (this.typeKey === 'REAPER') {
            ctx.fillStyle = `rgba(0, 0, 0, 0.4)`;
            ctx.beginPath(); ctx.arc(this.x, this.y, s * 1.5, 0, Math.PI*2); ctx.fill();
            if (this.skillTimer > 200) { 
                ctx.strokeStyle = `rgba(180, 0, 255, ${(this.skillTimer-200)/40})`;
                ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, 3.5*TILE_SIZE*((240-this.skillTimer)/40), 0, Math.PI*2); ctx.stroke();
            }
        }

        if (this.fly) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.arc(this.x+4, this.y+4, s, 0, Math.PI*2); ctx.fill();
        }
        if (this.webbed > 0) {
            ctx.strokeStyle = 'rgba(200,200,255,0.7)'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(this.x-s, this.y-s); ctx.lineTo(this.x+s, this.y+s);
            ctx.moveTo(this.x+s, this.y-s); ctx.lineTo(this.x-s, this.y+s); ctx.stroke();
        }
        ctx.fillStyle = this.color;
        
        if (this.typeKey === 'MEDIC') {
            ctx.beginPath(); ctx.arc(this.x, this.y, s, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x - s/2, this.y - 2, s, 4); ctx.fillRect(this.x - 2, this.y - s/2, 4, s);
        } else if (this.typeKey === 'REAPER') {
            ctx.beginPath(); ctx.moveTo(this.x, this.y - s); ctx.lineTo(this.x + s, this.y + s); ctx.lineTo(this.x - s, this.y + s); ctx.fill();
            ctx.strokeStyle = '#eee'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(this.x+5, this.y+5); ctx.lineTo(this.x+15, this.y-10); ctx.stroke();
            ctx.beginPath(); ctx.arc(this.x+10, this.y-10, 8, Math.PI, Math.PI*1.8); ctx.stroke();
        } else if (this.typeKey === 'DASHER') {
            ctx.beginPath(); ctx.moveTo(this.x + s, this.y); ctx.lineTo(this.x - s, this.y - s); ctx.lineTo(this.x - s/2, this.y); ctx.lineTo(this.x - s, this.y + s); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(this.x, this.y, s, 0, Math.PI*2); ctx.fill();
        }

        if (this.border) { ctx.lineWidth = 2; ctx.strokeStyle = this.border; ctx.stroke(); }
        const hpPct = Math.max(0, this.hp / this.maxHp);
        const w = TILE_SIZE * 0.8;
        ctx.fillStyle = '#b71c1c'; ctx.fillRect(this.x-w/2, this.y-s-6, w*hpPct, 3);
        if (this.shield > 0) {
            const shPct = Math.max(0, this.shield / this.maxShield);
            ctx.fillStyle = '#eee'; ctx.fillRect(this.x-w/2, this.y-s-6, w*shPct, 3); 
        }
    }
}

class Zone {
    constructor(x, y, radius, damage, duration, color) {
        this.x = x; this.y = y; this.radius = radius;
        this.damage = damage; 
        this.life = duration; 
        this.maxLife = duration;
        this.color = color || '#d50000'; 
    }
    update() {
        this.life--;
        if (this.life % 10 === 0) {
            enemies.forEach(e => {
                if(!e.active || e.fly) return; 
                if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) {
                    e.takeDamage(this.damage/6, 'nuke', null);
                }
            });
        }
    }
    draw() {
        ctx.globalAlpha = 0.3 * (this.life / this.maxLife);
        ctx.fillStyle = this.color; 
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Tower {
    constructor(c, r, typeKey) {
        this.c = c; this.r = r;
        this.x = c * TILE_SIZE + TILE_SIZE/2;
        this.y = r * TILE_SIZE + TILE_SIZE/2;
        this.type = JSON.parse(JSON.stringify(TOWER_TYPES[typeKey])); 
        this.baseType = typeKey;
        this.cd = 0;
        this.level = 1;
        this.maxLevel = 10;
        this.drones = [];
        this.bountyBuff = 0;
        
        this.vulcanHeat = 0; 
        this.laserTarget = null;
        this.heat = 0;
        this.subTargets = [];
        this.salvoLeft = 0;
        this.salvoDelay = 0;
        
        this.frozen = 0;
        
        this.buffStats = { dmgMult: 1.0, rangeMult: 1.0, cdr: 1.0, purified: false };
    }

    upgrade() {
        if (this.level >= this.maxLevel) return false;
        this.level++;
        this.type.damage *= 1.4; 
        this.type.range *= 1.05; 
        this.type.cooldown *= 0.95;
        createFloatingText(this.x, this.y, "UPGRADE!", "#00e676");
        return true;
    }

    update() {
        if (this.frozen > 0) {
            this.frozen--;
            if (this.cd > 0) this.cd--;
            return; 
        }

        const currentDamage = this.type.damage * this.buffStats.dmgMult;
        const currentRange = this.type.range * this.buffStats.rangeMult;
        
        if (this.cd > 0) this.cd--;
        if (this.bountyBuff > 0) this.bountyBuff--;

        if (this.baseType === 'VULCAN') {
             if (this.cd <= 0 && this.vulcanHeat > 0) {
                 this.vulcanHeat = Math.max(0, this.vulcanHeat - 1);
             }
        }

        if (this.baseType === 'PRISM') {
            const rangePx = currentRange * TILE_SIZE;
            if (this.laserTarget && (!this.laserTarget.active || Math.hypot(this.laserTarget.x - this.x, this.laserTarget.y - this.y) > rangePx)) {
                this.laserTarget = null; this.subTargets = []; this.heat = Math.max(0, this.heat - 0.5); 
            }
            if (!this.laserTarget) {
                this.laserTarget = this.findTarget(rangePx, 'any'); 
                if(!this.laserTarget) this.heat = Math.max(0, this.heat - 0.1);
            }
            if (this.laserTarget) {
                this.heat = Math.min(3, this.heat + 0.05); 
                const mainDmg = currentDamage * (1 + this.heat) * 0.1; 
                this.laserTarget.takeDamage(mainDmg, 'prism', this);
                this.subTargets = [];
                const maxSplits = 1 + Math.floor((this.level-1) / 2);
                let found = 0;
                const refractRange = 3.5 * TILE_SIZE;
                for (let e of enemies) {
                    if (found >= maxSplits) break;
                    if (e !== this.laserTarget && e.active) {
                        if (Math.hypot(e.x - this.laserTarget.x, e.y - this.laserTarget.y) < refractRange) {
                            e.takeDamage(mainDmg * 0.5, 'prism', this);
                            this.subTargets.push(e);
                            found++;
                        }
                    }
                }
            }
        }

        else if (this.baseType === 'MISSILE') {
            if (this.salvoLeft > 0) {
                this.salvoDelay--;
                if (this.salvoDelay <= 0) {
                    const t = this.findTarget(99999, 'air');
                    if (t) {
                        this.fire(t, currentDamage); 
                        this.salvoLeft--;
                        this.salvoDelay = 8;
                    } else { this.salvoLeft = 0; }
                }
            }
            else if (this.cd <= 0) {
                const missileCount = 1 + Math.ceil(this.level / 2);
                if (this.findTarget(99999, 'any')) {
                    this.salvoLeft = missileCount;
                    this.cd = this.type.cooldown * this.buffStats.cdr;
                }
            }
        }

        else if (this.baseType === 'GOLD') {
            const auraRange = this.buffStats.rangeMult > 1 ? currentRange * 1.5 : currentRange; 
            
            if (this.cd % 60 === 0) {
                const rangePx = auraRange * TILE_SIZE;
                towers.forEach(t => {
                    if (t !== this && Math.hypot(t.x - this.x, t.y - this.y) < rangePx) {
                        t.bountyBuff = this.buffStats.purified ? 120 : 70; 
                    }
                });
            }

            if (this.cd <= 0) {
                let amount = Math.floor(40 * Math.pow(1.5, this.level - 1));
                if (this.buffStats.dmgMult > 1) amount = Math.floor(amount * this.buffStats.dmgMult); 
                gold += amount;
                
                const txt = this.buffStats.dmgMult > 1 ? `üíé+${amount}` : `+${amount}`;
                createFloatingText(this.x, this.y, txt, '#ffd700');
                
                this.cd = this.type.cooldown * 60 * this.buffStats.cdr;
                const goldDisplay = document.getElementById('gold-display');
                goldDisplay.innerText = Math.floor(gold);
                goldDisplay.classList.add('gain');
                setTimeout(() => goldDisplay.classList.remove('gain'), 200);
            }
        } 
        
        else if (this.baseType !== 'BUFF' && this.cd <= 0) {
            let targetMode = 'ground';
            if (this.baseType === 'FLAK' || this.baseType === 'NET') targetMode = 'air';
            else if (this.baseType === 'TESLA' || this.baseType === 'VULCAN') targetMode = 'any';
            else if (this.baseType === 'NUKE' || this.baseType === 'MAGMA') targetMode = 'ground';

            const rangePx = currentRange * TILE_SIZE;
            const target = this.findTarget(rangePx, targetMode);
            
            if (target) { 
                this.fire(target, currentDamage); 
                
                if (this.baseType === 'VULCAN') {
                    this.vulcanHeat = Math.min(100, this.vulcanHeat + 5);
                    const speedBoost = 1 - (this.vulcanHeat / 120); 
                    this.cd = Math.max(2, Math.floor(this.type.cooldown * speedBoost * this.buffStats.cdr));
                } else {
                    this.cd = this.type.cooldown * this.buffStats.cdr; 
                }
            }
        }
        
        const isSwarmMode = this.drones.length >= 4; 
        this.drones.forEach(d => {
            d.angle += isSwarmMode ? 0.25 : 0.15; 
            if (d.cd > 0) d.cd--;
            else {
                const rangePx = TOWER_TYPES.DRONE.range * TILE_SIZE;
                let t = this.findTarget(rangePx, 'any'); 
                if (t) {
                    let dmg = TOWER_TYPES.DRONE.damage + (this.level * 25);
                    if (isSwarmMode) dmg *= 1.2; 
                    dmg *= this.buffStats.dmgMult; 
                    projectiles.push(new Projectile(
                        this.x + Math.cos(d.angle)*15, this.y + Math.sin(d.angle)*15,
                        t, dmg, 'drone'
                    ));
                    d.cd = (isSwarmMode ? TOWER_TYPES.DRONE.cooldown / 2 : TOWER_TYPES.DRONE.cooldown) * this.buffStats.cdr;
                }
            }
        });
    }

    findTarget(range, mode) {
        let best = null, maxHp = -1;
        for (let e of enemies) {
            if (!e.active) continue;
            if (mode === 'air' && !e.fly) continue;
            if (mode === 'ground' && e.fly) continue;

            const dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist <= range) {
                if (this.baseType === 'MISSILE' || this.baseType === 'NUKE' || this.baseType === 'PRISM') {
                     if (e.hp > maxHp) { maxHp = e.hp; best = e; }
                } else {
                     if (!best || e.pathIdx > best.pathIdx) best = e;
                }
            }
        }
        return best;
    }

    fire(target, dmg) {
        if (this.baseType === 'NUKE') {
            shakeScreen(20);
            zones.push(new Zone(target.x, target.y, 4.0 * TILE_SIZE, dmg, 300, '#d50000'));
            createExplosion(target.x, target.y, 4.5 * TILE_SIZE, '#ff3d00');
            enemies.forEach(e => {
                if (Math.hypot(e.x - target.x, e.y - target.y) < 4.0 * TILE_SIZE && !e.fly) {
                    e.takeDamage(dmg, 'nuke', this);
                }
            });
            return;
        }

        if (this.baseType === 'TESLA') {
            createLightning(this.x, this.y, target.x, target.y, this.level);
            target.takeDamage(dmg, 'tesla', this);
            this.triggerStaticNova(target, dmg * 0.4); 
            this.chainLightning(target, 3 + this.level, dmg * 0.9, [target]);
            return;
        }

        projectiles.push(new Projectile(this.x, this.y, target, dmg, this.type.id, this));
    }

    triggerStaticNova(centerE, novaDmg) {
        visualEffects.push({type:'nova', x:centerE.x, y:centerE.y, life:10});
        const range = 1.5 * TILE_SIZE;
        enemies.forEach(e => {
            if(e.active && e !== centerE && Math.hypot(e.x - centerE.x, e.y - centerE.y) < range) {
                e.takeDamage(novaDmg, 'tesla_nova', this);
            }
        });
    }

    chainLightning(lastTarget, jumps, dmg, hitList) {
        if (jumps <= 0) return;
        const range = 3.5 * TILE_SIZE; 
        let bestNext = null;
        for (let e of enemies) {
            if (!e.active || hitList.includes(e)) continue; 
            if (Math.hypot(e.x - lastTarget.x, e.y - lastTarget.y) < range) {
                bestNext = e; break; 
            }
        }
        if (bestNext) {
            createLightning(lastTarget.x, lastTarget.y, bestNext.x, bestNext.y, this.level);
            bestNext.takeDamage(dmg, 'tesla', this);
            this.triggerStaticNova(bestNext, dmg * 0.4); 
            hitList.push(bestNext);
            setTimeout(() => this.chainLightning(bestNext, jumps - 1, dmg * 0.9, hitList), 60);
        }
    }

    draw() {
        const scale = 0.8 + (this.level-1)*0.03; 
        const s = TILE_SIZE * Math.min(1.1, scale);
        
        if (this.baseType === 'BUFF') {
             const angle = Date.now() / 500;
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(angle);
             ctx.strokeStyle = '#00e676'; ctx.lineWidth = 2;
             ctx.beginPath(); ctx.moveTo(-s/2, 0); ctx.lineTo(s/2, 0); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(0, -s/2); ctx.lineTo(0, s/2); ctx.stroke();
             ctx.restore();
             
             const rangePx = this.type.range * TILE_SIZE;
             towers.forEach(t => {
                if (t !== this && t.baseType !== 'BUFF' && Math.hypot(t.x-this.x, t.y-this.y) < rangePx) {
                    ctx.strokeStyle = this.level >= 5 ? 'rgba(255, 235, 59, 0.6)' : 'rgba(0, 230, 118, 0.4)';
                    ctx.lineWidth = this.level >= 5 ? 2 : 1;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(t.x, t.y); ctx.stroke();
                }
             });
        }

        if (this.frozen > 0) ctx.fillStyle = '#555'; 
        else ctx.fillStyle = this.type.color;

        if (this.baseType === 'GOLD') {
             ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
             ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y, this.type.range * TILE_SIZE, 0, Math.PI*2); ctx.stroke();
             ctx.fillStyle = 'rgba(255, 215, 0, 0.05)'; ctx.fill();
        }

        if (this.bountyBuff > 0) {
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 10;
        }

        if (this.buffStats.dmgMult > 1.0) {
             ctx.shadowColor = this.buffStats.dmgMult >= 2.0 ? '#ffeb3b' : '#00e676';
             ctx.shadowBlur = 15;
        }

        if (this.frozen > 0) ctx.fillStyle = '#444'; 
        else ctx.fillStyle = this.type.color;
        
        ctx.fillRect(this.x - s/2, this.y - s/2, s, s);
        ctx.shadowBlur = 0; 
        ctx.strokeStyle = this.level >= 10 ? '#ffd700' : '#000';
        ctx.lineWidth = this.level >= 10 ? 3 : 1;
        ctx.strokeRect(this.x - s/2, this.y - s/2, s, s);
        
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.font = `${Math.floor(s*0.6)}px Arial`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.type.icon, this.x, this.y);

        if (this.frozen > 0) {
             ctx.font = '16px Arial'; ctx.fillStyle = '#f00'; ctx.fillText('üö´', this.x, this.y - s);
        }
        
        if (this.buffStats.purified) {
             ctx.fillStyle = '#00e676'; ctx.beginPath(); ctx.arc(this.x+s/2, this.y-s/2, 4, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
        }

        if (this.baseType === 'PRISM' && this.laserTarget) {
            const width = 2 + this.heat;
            const alpha = 0.5 + Math.min(0.5, this.heat/4);
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTarget.x, this.laserTarget.y);
            ctx.lineWidth = width; ctx.strokeStyle = `rgba(255, 0, 100, ${alpha})`;
            ctx.stroke(); 
            this.subTargets.forEach(sub => {
                ctx.beginPath(); ctx.moveTo(this.laserTarget.x, this.laserTarget.y); ctx.lineTo(sub.x, sub.y);
                ctx.lineWidth = width * 0.6; ctx.strokeStyle = `rgba(255, 100, 200, ${alpha * 0.8})`;
                ctx.stroke();
            });
            ctx.lineWidth = 1;
        }

        for(let i=0; i<this.level; i++) {
            let lx, ly, dotColor = '#fff';
            if (i < 5) {
                lx = this.x - s/2 + 4 + i*5; ly = this.y - s/2 + 4;
            } else {
                lx = this.x - s/2 + 4 + (i-5)*5; ly = this.y - s/2 + 10;
                dotColor = '#ffd700'; 
                if(this.level === 10) dotColor = '#00e676'; 
            }
            ctx.fillStyle = dotColor; ctx.beginPath(); ctx.arc(lx, ly, 2, 0, Math.PI*2); ctx.fill();
        }

        if (this.baseType === 'GOLD' || this.baseType === 'NUKE' || this.baseType === 'MISSILE' || this.baseType === 'MAGMA') {
             const maxCd = this.type.cooldown * (this.baseType === 'GOLD' ? 60 : 1);
             if (this.cd > 0) {
                ctx.fillStyle = '#555'; ctx.fillRect(this.x - s/2, this.y - s/2 - 4, s * (this.cd/maxCd), 3);
             } else if (this.baseType === 'MISSILE' && this.salvoLeft > 0) {
                 ctx.fillStyle = '#ff9100'; ctx.fillRect(this.x - s/2, this.y - s/2 - 4, s * (this.salvoLeft/6), 3);
             }
        }

        if (this.baseType === 'VULCAN' && this.vulcanHeat > 0) {
            ctx.fillStyle = `rgb(255, ${255 - this.vulcanHeat*2}, 0)`;
            ctx.fillRect(this.x - s/2, this.y - s/2 - 4, s * (this.vulcanHeat/100), 3);
        }

        const swarm = this.drones.length >= 4;
        ctx.fillStyle = swarm ? '#f44336' : '#00bcd4'; 
        this.drones.forEach(d => {
            const dx = Math.cos(d.angle) * (TILE_SIZE*(swarm ? 0.7 : 0.6));
            const dy = Math.sin(d.angle) * (TILE_SIZE*(swarm ? 0.7 : 0.6));
            ctx.beginPath(); ctx.arc(this.x+dx, this.y+dy, swarm ? 4 : 3, 0, Math.PI*2); ctx.fill();
        });
        
        if (this.bountyBuff > 0) {
            ctx.font = '10px Arial'; ctx.fillStyle = '#ffea00';
            ctx.fillText('$', this.x + s/2 - 5, this.y - s/2 + 5);
        }
    }
}

class Projectile {
    constructor(x, y, target, dmg, type, sourceTower) {
        this.x = x; this.y = y; this.target = target;
        this.dmg = dmg; this.type = type;
        this.sourceTower = sourceTower; 
        this.speed = (type === 'missile') ? 4 : 14; 
        this.accel = (type === 'missile') ? 1.05 : 1;
        this.active = true;
        this.trailTimer = 0;
    }
    update() {
        if (!this.active) return;
        if (!this.target.active) { this.active = false; return; }
        
        if (this.type === 'missile') this.speed = Math.min(25, this.speed * this.accel);

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (this.type === 'missile') {
            this.trailTimer++;
            if (this.trailTimer % 2 === 0) visualEffects.push({type:'smoke', x:this.x, y:this.y, life:20});
        }

        if (dist < this.speed) {
            this.active = false;
            
            if (this.type === 'magma') {
                createExplosion(this.x, this.y, 1.5 * TILE_SIZE, '#ff5722');
                this.target.takeDamage(this.dmg, 'magma', this.sourceTower);
                zones.push(new Zone(this.x, this.y, 1.8 * TILE_SIZE, this.dmg, 180, 'rgba(255, 87, 34, 0.5)'));
            }

            else if (this.type === 'net') {
                const duration = this.sourceTower && this.sourceTower.buffStats.purified ? 250 : 150;
                this.target.webbed = duration; 
                this.target.takeDamage(this.dmg, 'net', this.sourceTower);
            } else if (this.type === 'flak') {
                createExplosion(this.x, this.y, 2.5 * TILE_SIZE, '#78909c');
                enemies.forEach(e => {
                    if (e.fly && Math.hypot(e.x - this.x, e.y - this.y) < 2.5 * TILE_SIZE) e.takeDamage(this.dmg, 'flak', this.sourceTower);
                });
            } else if (this.type === 'missile') {
                createExplosion(this.x, this.y, 2.2 * TILE_SIZE, '#ffab00');
                this.target.takeDamage(this.dmg, 'missile', this.sourceTower); 
                enemies.forEach(e => {
                    if (e.fly && e !== this.target && Math.hypot(e.x - this.x, e.y - this.y) < 2.2 * TILE_SIZE) {
                         e.takeDamage(this.dmg * 0.6, 'missile', this.sourceTower);
                    }
                });
            } else {
                this.target.takeDamage(this.dmg, this.type, this.sourceTower);
            }
        } else {
            this.x += (dx/dist)*this.speed;
            this.y += (dy/dist)*this.speed;
        }
    }
    draw() {
        if (this.type === 'net') ctx.fillStyle = '#aa00ff';
        else if (this.type === 'flak') ctx.fillStyle = '#b0bec5';
        else if (this.type === 'missile') ctx.fillStyle = '#ff9100';
        else if (this.type === 'vulcan') ctx.fillStyle = '#ff8a65';
        else if (this.type === 'magma') ctx.fillStyle = '#ff5722';
        else if (this.type === 'drone') ctx.fillStyle = '#00bcd4';
        else ctx.fillStyle = '#fff';
        
        const size = (this.type === 'missile') ? 4 : (this.type === 'vulcan' ? 2 : 3);
        ctx.beginPath(); ctx.arc(this.x, this.y, size, 0, Math.PI*2); ctx.fill();
    }
}

let visualEffects = [];
function createExplosion(x, y, radius, color) {
    visualEffects.push({ type: 'explosion', x, y, radius, color, life: 20, maxLife: 20 });
}
function createLightning(x1, y1, x2, y2, level) {
    visualEffects.push({ type: 'lightning', x1, y1, x2, y2, life: 8, level: level });
}
function createFloatingText(x, y, txt, col) {
    particles.push({x,y,txt,color:col,life:40, vy: -1.0});
}
function shakeScreen(amount) { shakeTimer = amount; }

function drawVisuals() {
    for (let i = visualEffects.length - 1; i >= 0; i--) {
        const v = visualEffects[i];
        v.life--;
        if (v.type === 'explosion') {
            const p = 1 - v.life/v.maxLife;
            ctx.fillStyle = v.color; ctx.globalAlpha = 0.6 * (1-p);
            ctx.beginPath(); ctx.arc(v.x, v.y, v.radius * p, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        } else if (v.type === 'smoke') {
            ctx.fillStyle = 'rgba(100,100,100,0.5)';
            ctx.beginPath(); ctx.arc(v.x, v.y, 2 + (20-v.life)/5, 0, Math.PI*2); ctx.fill();
        } else if (v.type === 'lightning') {
            let col = '150, 220, 255';
            if (v.level > 5) col = '200, 150, 255';
            if (v.level >= 10) col = '255, 255, 255';
            
            ctx.strokeStyle = `rgba(${col}, ${v.life/8})`;
            ctx.lineWidth = v.level >= 8 ? 3 : 2; 
            ctx.beginPath(); ctx.moveTo(v.x1, v.y1);
            ctx.lineTo((v.x1+v.x2)/2+(Math.random()-0.5)*20, (v.y1+v.y2)/2+(Math.random()-0.5)*20);
            ctx.lineTo(v.x2, v.y2); ctx.stroke();
        } else if (v.type === 'nova') {
            ctx.strokeStyle = `rgba(100, 200, 255, ${v.life/10})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(v.x, v.y, (10-v.life)*4, 0, Math.PI*2);
            ctx.stroke();
        }
        else if (v.type === 'heal_beam') {
            const alpha = v.life / v.maxLife;
            ctx.strokeStyle = `rgba(0, 230, 118, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(v.x, v.y); ctx.lineTo(v.tx, v.ty); ctx.stroke();
            ctx.fillStyle = `rgba(0, 230, 118, ${alpha})`; ctx.fillRect(v.tx-2, v.ty-2, 4, 4);
        }
        else if (v.type === 'dash_trail') {
             ctx.globalAlpha = v.life / 20;
             ctx.fillStyle = v.color;
             ctx.beginPath(); ctx.arc(v.x, v.y, TILE_SIZE*0.3, 0, Math.PI*2); ctx.fill();
             ctx.globalAlpha = 1;
        }

        if (v.life <= 0) visualEffects.splice(i, 1);
    }
}

// ================= Ê∏∏ÊàèÊéßÂà∂‰∏éÂ∫èÂàóÂåñÁ≥ªÁªü =================

function gameLoop() {
    if (gameState !== STATE.PLAYING) {
        if (gameState === STATE.PAUSED) {
            // ÊöÇÂÅúÊó∂‰∏çÊõ¥Êñ∞ÈÄªËæëÔºåÂè™ÁªòÂà∂ÁîªÈù¢‰øùÊåÅËÉåÊôØ
            drawGameScene();
        }
        requestAnimationFrame(gameLoop);
        return;
    }

    // --- Ê∏∏ÊàèÈÄªËæëÊõ¥Êñ∞ ---
    const shaker = document.getElementById('shaker');
    if (shakeTimer > 0) {
        shakeTimer--;
        shaker.style.transform = `translate(${(Math.random()-0.5)*8}px, ${(Math.random()-0.5)*8}px)`;
    } else { shaker.style.transform = `translate(0, 0)`; }

    // Ê≥¢Ê¨°ÈÄªËæë
    if (!waveActive && autoWave) {
        if (enemies.length === 0 && spawnQueue.length === 0) {
            if (autoTimer > 0) {
                autoTimer--;
                document.getElementById('countdown-overlay').style.display = 'block';
                document.getElementById('cd-num').innerText = Math.ceil(autoTimer / 60);
            } else { startWaveLogic(); }
        }
    }

    if (waveActive && spawnQueue.length > 0) {
        spawnTimer--;
        if (spawnTimer <= 0) {
            enemies.push(new Enemy(spawnQueue.shift()));
            spawnTimer = Math.max(5, 20 - Math.floor(wave/3)); 
        }
    } else if (spawnQueue.length === 0 && enemies.length === 0) {
        waveActive = false;
        document.getElementById('wave-control-btn').innerText = "‚öîÔ∏è ÊàòÊñóÂºÄÂßã";
        document.getElementById('wave-control-btn').disabled = false;
    }

    // Buff ÈáçÁΩÆ
    towers.forEach(t => {
        t.buffStats = { dmgMult: 1.0, rangeMult: 1.0, cdr: 1.0, purified: false };
    });

    // Â¢ûÂπÖÂô®ÈÄªËæë
    towers.forEach(t => {
        if (t.baseType === 'BUFF') {
            const rangePx = t.type.range * TILE_SIZE;
            const isSuper = t.level >= 5; 
            const dmgBoost = isSuper ? 2.0 : 1.5; 
            
            towers.forEach(other => {
                if (other !== t && other.baseType !== 'BUFF') {
                    if (Math.hypot(other.x - t.x, other.y - t.y) < rangePx) {
                        other.buffStats.dmgMult = Math.max(other.buffStats.dmgMult, dmgBoost);
                        other.buffStats.rangeMult = 1.2;
                        other.buffStats.cdr = 0.8;
                        other.buffStats.purified = true;
                        other.frozen = 0; 
                    }
                }
            });
        }
    });

    zones.forEach(z => z.update());
    zones = zones.filter(z => z.life > 0);

    towers.forEach(t => t.update());
    enemies = enemies.filter(e => e.active);
    enemies.forEach(e => e.update());
    projectiles.forEach(p => p.update());
    projectiles = projectiles.filter(p => p.active);
    
    for(let i=particles.length-1; i>=0; i--) {
        let pt = particles[i]; pt.y += pt.vy; pt.life--;
        if(pt.life<=0) particles.splice(i,1);
    }

    drawGameScene();
    requestAnimationFrame(gameLoop);
}

function drawGameScene() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    
    // ÁªòÂà∂Âú∞Âõæ
    for(let r=0; r<MAP_ROWS; r++){
        for(let c=0; c<MAP_COLS; c++){
            const x = c*TILE_SIZE, y = r*TILE_SIZE;
            ctx.fillStyle = (map[r][c]===1)?'#111':'#222';
            ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
            ctx.strokeStyle = '#333'; ctx.strokeRect(x,y,TILE_SIZE,TILE_SIZE);
        }
    }

    zones.forEach(z => z.draw());
    towers.forEach(t => t.draw());
    enemies.forEach(e => e.draw());
    projectiles.forEach(p => p.draw());
    drawVisuals();

    // Á≤íÂ≠ê
    for(let i=particles.length-1; i>=0; i--) {
        let pt = particles[i]; 
        ctx.globalAlpha = pt.life / 30; ctx.fillStyle = pt.color;
        ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center';
        ctx.fillText(pt.txt, pt.x, pt.y); ctx.globalAlpha = 1;
    }
}

function togglePause() {
    if (gameState === STATE.PLAYING) {
        gameState = STATE.PAUSED;
        document.getElementById('pause-screen').classList.remove('hidden');
        document.getElementById('pause-btn').innerText = '‚ñ∂';
    } else if (gameState === STATE.PAUSED) {
        gameState = STATE.PLAYING;
        document.getElementById('pause-screen').classList.add('hidden');
        document.getElementById('pause-btn').innerText = '‚è∏';
    }
}

function toggleAuto() {
    autoWave = !autoWave;
    const btn = document.getElementById('auto-switch');
    if (autoWave) {
        btn.classList.add('on');
        if (!waveActive) autoTimer = 60 * AUTO_DELAY_SEC; 
    } else {
        btn.classList.remove('on');
        document.getElementById('countdown-overlay').style.display = 'none';
    }
}

function manualNextWave() {
    if (waveActive) return;
    startWaveLogic();
}

function startWaveLogic() {
    wave++;
    waveActive = true;
    autoTimer = 60 * AUTO_DELAY_SEC; 
    document.getElementById('countdown-overlay').style.display = 'none';
    document.getElementById('wave-display').innerText = wave;
    document.getElementById('wave-control-btn').innerText = `üî• WAVE ${wave} !!`;
    document.getElementById('wave-control-btn').disabled = true;

    spawnQueue = [];
    const count = 18 + Math.floor(wave * 2.3); 
    for(let i=0; i<count; i++) {
        const rand = Math.random();
        if (wave % 5 === 0 && i < 4) spawnQueue.push('BOSS'); 
        else if (wave > 20 && rand < 0.08) spawnQueue.push('BOSS'); 
        else if (wave > 15 && rand < 0.06) spawnQueue.push('REAPER');
        else if (wave > 25 && rand < 0.1) spawnQueue.push('REAPER');
        else if (wave > 10 && rand < 0.12) spawnQueue.push('DASHER');
        else if (wave > 40 && rand < 0.1) spawnQueue.push('FLY_H');
        else if (wave > 8 && rand < 0.15) spawnQueue.push('SPIDER'); 
        else if (wave > 4 && rand < 0.28) spawnQueue.push('MEDIC'); 
        else if (i % 6 === 0 && wave > 4) spawnQueue.push('TANK');
        else if (rand < 0.2 && wave > 2) spawnQueue.push('FLY'); 
        else if (rand < 0.3 && wave > 5) spawnQueue.push('GHOST');
        else if (rand < 0.4 && wave > 3) spawnQueue.push('FAST');
        else if (rand < 0.5 && wave > 3) spawnQueue.push('SHIELD');
        else spawnQueue.push('NORMAL');
    }
}

function selectTower(key) {
    if (gameState !== STATE.PLAYING) return;
    selectedTower = (selectedTower === key) ? null : key;
    updateUI();
    const t = document.getElementById('toast');
    if (selectedTower) {
        const type = TOWER_TYPES[selectedTower];
        t.innerHTML = `<div>${type.name}</div><div class="sub">ÂçáÁ∫ß = Âéü‰ª∑ x Á≠âÁ∫ß</div>`;
        t.style.opacity = 1;
        clearTimeout(t.timer);
        t.timer = setTimeout(() => t.style.opacity = 0, 3000);
    }
}

function updateUI() {
    document.getElementById('gold-display').innerText = Math.floor(gold);
    document.getElementById('life-display').innerText = lives;
    for (let key in TOWER_TYPES) {
        const btn = document.getElementById('btn-'+key);
        const cost = TOWER_TYPES[key].cost;
        if (selectedTower === key) btn.classList.add('active'); else btn.classList.remove('active');
        if (gold < cost) btn.classList.add('disabled'); else btn.classList.remove('disabled');
    }
}

canvas.addEventListener('pointerup', e => {
    e.preventDefault();
    if (gameState !== STATE.PLAYING) return;
    if (!selectedTower) return;
    
    const rect = canvas.getBoundingClientRect();
    const c = Math.floor((e.clientX - rect.left) / TILE_SIZE);
    const r = Math.floor((e.clientY - rect.top) / TILE_SIZE);
    if (c<0 || c>=MAP_COLS || r<0 || r>=MAP_ROWS) return;
    
    const existing = towers.find(t => t.c === c && t.r === r);
    const baseCost = TOWER_TYPES[selectedTower].cost;
    
    if (selectedTower === 'DRONE') {
        if (existing) {
            const maxDrones = existing.buffStats.purified ? 6 : 4; 
            if (gold >= baseCost) {
                if (existing.drones.length < maxDrones) { 
                    existing.drones.push({angle:0, cd:0});
                    gold -= baseCost;
                    createFloatingText(existing.x, existing.y, "ÊåÇËΩΩ!", "#0ff");
                } else { createFloatingText(existing.x, existing.y, "ÊåÇËΩΩÂ∑≤Êª°", "#f00"); }
            }
        }
        updateUI(); return;
    }

    if (map[r][c] === 0) { 
        if (existing) {
            if (existing.baseType === selectedTower) {
                const upgradeCost = baseCost * existing.level;
                if (gold >= upgradeCost) {
                    if (existing.upgrade()) {
                        gold -= upgradeCost;
                        createFloatingText(existing.x, existing.y, `-${upgradeCost}`, "#ffd700");
                    } else { createFloatingText(existing.x, existing.y, "Â∑≤Êª°Á∫ß", "#f00"); }
                } else { createFloatingText(existing.x, existing.y, `Áº∫Èí±`, "#f00"); }
            } else { createFloatingText(existing.x, existing.y, "Êó†Ê≥ïË¶ÜÁõñ", "#f00"); }
        } else {
            if (gold >= baseCost) {
                gold -= baseCost;
                towers.push(new Tower(c, r, selectedTower));
                createFloatingText(c*TILE_SIZE+20, r*TILE_SIZE+20, "-"+baseCost, "#fff");
            }
        }
        updateUI();
    }
});

// ================= Â≠òÊ°£/ËØªÊ°£Á≥ªÁªü (ÂèçAI Ê∑∑Ê∑ÜÁâà) =================

const ObscureStorage = {
    // Âõ∫ÂÆöÁöÑ‚ÄúÂô™Â£∞‚Äù‰πòÊï∞ÔºåÁî®‰∫éÊ±°ÊüìÊï∞ÂÄº„ÄÇÂ≠òÊ°£Èáå‰∏çÂ≠òÁúüÂÄº„ÄÇ
    SALT_MULT: [13, 7, 23, 11, 19, 5, 17], 
    
    // ÁÆÄÂçïÁöÑÊªöÂä®ÂºÇÊàñÂä†ÂØÜ„ÄÇÂØÜÈí•Ê†πÊçÆÂâç‰∏Ä‰∏™Â≠óÁ¨¶ÂèòÂåñÔºåÂØºËá¥Êó†Ê≥ïÈÄöËøáÁÆÄÂçïÈ¢ëÁéáÂàÜÊûêÁ†¥Ëß£„ÄÇ
    encrypt: function(numArray) {
        let res = "";
        let key = 0xAB; // ÂàùÂßãÁßçÂ≠ê
        for (let i = 0; i < numArray.length; i++) {
            let val = numArray[i];
            if (val < 0) val = 0; // ‰øùÊä§
            
            // Êï∞ÊçÆÊ±°ÊüìÔºöval * SALT + Index
            let saltedVal = val * this.SALT_MULT[i % this.SALT_MULT.length] + (i * 3);
            
            // ÁÆÄÂçïÁöÑËΩ¨ Hex Â≠óÁ¨¶‰∏≤Â§ÑÁêÜÔºåÂä†ÂàÜÈöîÁ¨¶
            let strVal = saltedVal.toString(16);
            
            // Âä†ÂØÜÂ≠óÁ¨¶‰∏≤ÁöÑÊØè‰∏™Â≠óÁ¨¶
            for (let j = 0; j < strVal.length; j++) {
                let code = strVal.charCodeAt(j);
                let enc = code ^ key;
                key = (key + 5) % 255; // ÊªöÂä® key
                res += enc.toString(16).padStart(2, '0');
            }
            res += "X"; // ÂàÜÈöîÁ¨¶
        }
        // Ê∑ªÂä†Ê†°È™åÂíå
        let sum = 0;
        for(let i=0; i<res.length; i++) sum = (sum + res.charCodeAt(i)) % 997;
        return res + "S" + sum.toString(16);
    },

    decrypt: function(str) {
        try {
            // 1. Ê†°È™åÂíåÊ£ÄÊü•
            let parts = str.split("S");
            if (parts.length !== 2) throw "Format Error";
            let body = parts[0];
            let check = parseInt(parts[1], 16);
            
            let sum = 0;
            for(let i=0; i<body.length; i++) sum = (sum + body.charCodeAt(i)) % 997;
            if (sum !== check) throw "Integrity Check Failed";

            // 2. Ëß£ÂØÜ
            let rawHexItems = body.split("X");
            let result = [];
            let key = 0xAB;

            for (let i = 0; i < rawHexItems.length; i++) {
                let item = rawHexItems[i];
                if (item === "") continue;

                let realStr = "";
                for (let j = 0; j < item.length; j += 2) {
                    let hex = item.substr(j, 2);
                    let code = parseInt(hex, 16);
                    let dec = code ^ key;
                    key = (key + 5) % 255;
                    realStr += String.fromCharCode(dec);
                }

                // 3. ÂéªÊ±°Êüì
                let saltedVal = parseInt(realStr, 16);
                let val = (saltedVal - (i * 3)) / this.SALT_MULT[i % this.SALT_MULT.length];
                result.push(val);
            }
            return result;
        } catch (e) {
            console.error(e);
            return null;
        }
    }
};

function exportSave() {
    // ÊûÑÈÄ†‰∏Ä‰∏™Âπ≥Èì∫ÁöÑÊï∞Â≠óÊï∞ÁªÑÔºåÂéªÊéâÊâÄÊúâ KeyÔºåAIÊó†Ê≥ïÁåúÊµã [1, 2, 6000] Ë∞ÅÊòØÈáëÂ∏Å
    let stream = [];

    // --- ÂÖ®Â±ÄÂèòÈáèÂå∫ (È°∫Â∫èÂõ∫ÂÆö) ---
    // 0: Gold, 1: Lives, 2: Wave, 3: Active(0/1), 4: Auto(0/1)
    stream.push(Math.floor(gold));
    stream.push(lives);
    stream.push(wave);
    stream.push(waveActive ? 1 : 0);
    stream.push(autoWave ? 1 : 0);

    // --- Â°îÊï∞ÊçÆ ---
    // Ê†ºÂºèÔºö[ÊÄªÊï∞, TypeID, Level, Col, Row, VulcanHeat, DronesCount, ...DronesCD, TypeID, ...]
    stream.push(towers.length);
    towers.forEach(t => {
        let typeIdx = TOWER_KEYS.indexOf(t.baseType);
        stream.push(typeIdx);
        stream.push(t.level);
        stream.push(t.c);
        stream.push(t.r);
        stream.push(Math.floor(t.vulcanHeat));
        stream.push(t.drones.length);
    });

    // --- Êïå‰∫∫Êï∞ÊçÆ ---
    // Ê†ºÂºè: [ÊÄªÊï∞, TypeID, X(int), Y(int), HP, Shield, PathIdx, ...]
    stream.push(enemies.length);
    enemies.forEach(e => {
        let typeIdx = ENEMY_KEYS.indexOf(e.typeKey);
        stream.push(typeIdx);
        stream.push(Math.floor(e.x));
        stream.push(Math.floor(e.y));
        stream.push(Math.floor(e.hp));
        stream.push(Math.floor(e.shield));
        stream.push(e.pathIdx);
    });

    // Âä†ÂØÜÂπ∂‰∏ãËΩΩ
    const encrypted = ObscureStorage.encrypt(stream);
    const blob = new Blob([encrypted], {type: "text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `save_${Date.now()}.pds`; // Planet Defense Save
    a.click();
}

function handleFileImport(input) {
    const file = input.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const data = ObscureStorage.decrypt(content);

        if (!data) {
            alert("‚ùå Â≠òÊ°£ÊçüÂùèÊàñË¢´ÁØ°Êîπ (Anti-AI Check Failed)");
            return;
        }

        try {
            let ptr = 0; // ËØªÂèñÊåáÈíà

            // ÊÅ¢Â§çÂÖ®Â±Ä
            gold = data[ptr++];
            lives = data[ptr++];
            wave = data[ptr++];
            waveActive = data[ptr++] === 1;
            autoWave = data[ptr++] === 1;

            // ÊÅ¢Â§ç UI
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('wave-control-btn').innerText = waveActive ? `üî• WAVE ${wave} !!` : "‚öîÔ∏è ÊàòÊñóÂºÄÂßã";
            document.getElementById('wave-control-btn').disabled = waveActive;
            if(autoWave) document.getElementById('auto-switch').classList.add('on');
            else document.getElementById('auto-switch').classList.remove('on');

            // ÊÅ¢Â§çÂ°î
            towers = [];
            const towerCount = data[ptr++];
            for(let i=0; i<towerCount; i++) {
                const typeKey = TOWER_KEYS[data[ptr++]];
                const level = data[ptr++];
                const c = data[ptr++];
                const r = data[ptr++];
                const vHeat = data[ptr++];
                const dCount = data[ptr++];

                const t = new Tower(c, r, typeKey);
                t.level = level;
                t.vulcanHeat = vHeat;
                
                // ÊÅ¢Â§çÊó†‰∫∫Êú∫
                for(let k=0; k<dCount; k++) t.drones.push({angle: Math.random()*6, cd: 0});
                
                // Â±ûÊÄßÈáçÁÆó
                t.type.damage *= Math.pow(1.4, t.level - 1);
                t.type.range *= Math.pow(1.05, t.level - 1);
                t.type.cooldown *= Math.pow(0.95, t.level - 1);
                towers.push(t);
            }

            // ÊÅ¢Â§çÊïå‰∫∫
            enemies = [];
            const enemyCount = data[ptr++];
            for(let i=0; i<enemyCount; i++) {
                const typeKey = ENEMY_KEYS[data[ptr++]];
                const x = data[ptr++];
                const y = data[ptr++];
                const hp = data[ptr++];
                const shield = data[ptr++];
                const pIdx = data[ptr++];

                const e = new Enemy(typeKey);
                e.x = x; e.y = y;
                e.hp = hp; e.maxHp = e.hp; // ÁÆÄÂåñÂ§ÑÁêÜÔºåmaxHpËøë‰ººÂΩìÂâç
                e.shield = shield;
                e.pathIdx = pIdx;
                
                if (e.fly) {
                    e.endX = path[path.length-1].c * TILE_SIZE + TILE_SIZE/2;
                    e.endY = path[path.length-1].r * TILE_SIZE + TILE_SIZE/2;
                }
                enemies.push(e);
            }

            // Ê∏ÖÁêÜÂÖ∂‰ªñ
            projectiles = [];
            particles = [];
            zones = [];

            alert("‚úÖ Ê∏∏ÊàèËΩΩÂÖ•ÊàêÂäüÔºÅ");
            document.getElementById('start-screen').classList.add('hidden');
            gameState = STATE.PAUSED;
            document.getElementById('pause-screen').classList.remove('hidden');
            updateUI();

        } catch (err) {
            console.error(err);
            alert("‚ùå Â≠òÊ°£Êï∞ÊçÆÁâàÊú¨‰∏çÂåπÈÖç");
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}

init();
</script>
<script src="https://api.suyanw.cn/api/mouse/yinghua.js"/></script>
</body>
</html>